#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 30 07:21:23 2018

ncbr_bsi_connect.py
    Functions for connecting to BSI for NCSI
    
"""
__author__ = 'Susan Huse'
__version__ = '1.0.0'
__copyright__ = 'none'

#import csv
import sys
import os
#import re
import datetime
#import subprocess
#import pandas as pd
from requests.auth import HTTPDigestAuth
import requests
 
####################################
# 
# Functions 
#
####################################

#
# Connect to BSI
#
def bsi_login(user, pw):
    url = 'https://httpbin.org/digest-auth/auth/user/pass'
    requests.get(url, auth=HTTPDigestAuth(user, pw))

#
# Run any command and send notice to log file.  if dorun=F, just notify for testing
#
def run_cmd(theCommand, fn, dorun):
    # Run the given command, x is a list of command parameters
    # if dorun = false, just send out the notification of the next python step
    print(" ".join(theCommand) + "\n")
    fn.write(" ".join(theCommand) + "\n")
    fn.flush()
    if dorun:
        subprocess.check_call(theCommand, stderr=fn)

#
# Read ~/.my.cnf and connect to an SQL database
#
def con_db(host_name, db_name, port_number):
    with open(os.path.expanduser("~/.my.cnf")) as f:
        ## [client]
        ## user="user_name"
        ## password="password"

        cnfdata = f.readlines()
        cnfdata = [x.strip() for x in cnfdata] 
        cnfdata = [x.replace('"', '') for x in cnfdata]
        user_name = cnfdata[1].replace('user=', '')
        password = cnfdata[2].replace('password=', '')
    
    db = MySQLdb.connect(host=host_name, db=db_name, port=port_number, user=user_name, passwd=password)
    return(db)

#
# Pause for user to be ready to continue, use contkey=None to get any input
#
def pause_for_input(txt, contkey='y', quitkey='q', log=None):

    # tally the number of tries
    ans_cnt = 0 

    # loop for the user to enter input, give them a few tries
    while True:

        # wait for the input
        ans = input(txt)

        # check if valid continue or quit keys
        if quitkey is not None and ans == quitkey:
            err_out("User elected to quit.  Exiting...\n", log)

        # if none, just return the input
        if contkey is None:
            return(ans)

        # if there is a contkey, then be sure it is correctly typed
        elif ans == contkey:
            return(ans)

        else:
        # give them additional help and increment the answer count
            reminder = "Note: only {} to continue and {} to quit are valid options.\nPlease try again.\n".format(contkey, quitkey)
            if ans_cnt == 0:
                txt = "\n" + txt + "\n" + reminder

            # Otherwise 3 strikes and exit from the loop
            if ans_cnt == 2:
                err_out("User failed to continue ({}) or quit ({}) three times in a row.  Exiting...".format(contkey, quitkey), log)

            ans_cnt = ans_cnt + 1 


#
# Connect to BSI with Curl
#

